esphome:
  name: esp-luxpower
  friendly_name: ESP-Luxpower

esp32:
  board: esp32dev
  framework:
    type: esp-idf

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

ota:
  - platform: esphome
    password: "11111111111111111111111111111111"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "Esp-Luxpower Fallback Hotspot"
    password: "rrrrrrrrrrrrrrrrrr"

captive_portal:

uart:
  - id: uart_modbus_inverter_1
    rx_pin: GPIO3
    tx_pin: GPIO1
    baud_rate: 19200
    stop_bits: 1
    parity: NONE
    data_bits: 8

modbus:
  - uart_id: uart_modbus_inverter_1
    id: modbus_inverter_1
    flow_control_pin: GPIO21

modbus_controller:
  - id: inverter_1
    address: 1
    update_interval: 5s
    modbus_id: modbus_inverter_1

  
  - id: inverter_1_slow
    update_interval: 60s
    modbus_id: modbus_inverter_1
    address: 1

binary_sensor:
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "AC Couple Enabled"
    register_type: read
    address: 77
    bitmask: 0x02 #(bit 8)

sensor:
  - platform: internal_temperature
    name: "ESP32 Internal Temperature"
    device_class: temperature
    entity_category: diagnostic
    unit_of_measurement: °C

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV1 Voltage"
    id: pv1_volt
    register_type: read
    address: 1
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 2
    value_type: U_WORD
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV2 Voltage"
    id: pv2_volt
    register_type: read
    address: 2
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 2
    value_type: U_WORD
    filters: 
      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Voltage"
    id: vbat
    register_type: read
    address: 4
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 2
    value_type: U_WORD
    filters: 
      - multiply: 0.1
#      - lambda: return x * 10;

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery State of Charge"
    id: bat_soc
    register_type: read
    address: 5
    bitmask: 0xFF
    unit_of_measurement: "%"
    state_class: measurement
    device_class: battery
    accuracy_decimals: 1
    value_type: U_WORD
#    lambda: return x & 0xFF;
  
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV 1 Power"
    id: pv1_pow
    register_type: read
    address: 7
    unit_of_measurement: "W"
    state_class: measurement
    device_class: "power"
    value_type: U_WORD
  
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "PV 2 Power"
    id: pv2_pow
    register_type: read
    address: 8
    unit_of_measurement: "W"
    state_class: measurement
    device_class: "power"
    value_type: U_WORD
  
  - platform: template
    id: pv_total_pow
    name: "PV Total Power"
    lambda: |-
      return (id(pv1_pow).state + id(pv2_pow).state);
    update_interval: 5s
    unit_of_measurement: "W"
    state_class: measurement
    device_class: "power"
    accuracy_decimals: 0
  
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Charge"
    id: bat_charge
    register_type: read
    address: 10
    unit_of_measurement: "W"
    state_class: measurement
    device_class: "power"
    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Discharge"
    id: bat_discharge
    register_type: read
    address: 11
    unit_of_measurement: "W"
    state_class: measurement
    device_class: "power"
    value_type: U_WORD

  - platform: template
    id: battery_power
    name: "Battery Power"
    lambda: |-
      return (id(bat_charge).state - id(bat_discharge).state);
    update_interval: 5s
    unit_of_measurement: "W"
    state_class: measurement
    device_class: "power"
    accuracy_decimals: 0
  
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Voltage"
    id: grid_volt
    register_type: read
    address: 12
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 2
    value_type: U_WORD
    filters: 
      - multiply: 0.1
  
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Frequency"
    id: grid_freq
    register_type: read
    address: 15
    unit_of_measurement: "Hz"
    state_class: measurement
    accuracy_decimals: 2
    value_type: U_WORD
    filters:
      - multiply: 0.01

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Grid Power"
    id: pinv
    register_type: read
    address: 27
    unit_of_measurement: "W"
    state_class: measurement
    value_type: U_WORD
  
#  - platform: modbus_controller
#    modbus_controller_id: inverter_1_slow
#    name: "PV1 Production (Today)"
#    id: epv1_day
#    register_type: read
#    address: 28
#    unit_of_measurement: "kWh"
#    device_class: energy
#    state_class: total_increasing
#    accuracy_decimals: 2
#    value_type: U_WORD
#    filters: 
#      - multiply: 0.1

#  - platform: modbus_controller
#    modbus_controller_id: inverter_1_slow
#    name: "PV2 Production (Today)"
#    id: epv2_day
#    register_type: read
#    address: 29
#    unit_of_measurement: "kWh"
#    device_class: energy
#    state_class: total_increasing
#    accuracy_decimals: 2
#    value_type: U_WORD
#    filters: 
#      - multiply: 0.1

#  - platform: template
#    name: "PV Total Production (Today)"
#    id: epv_total_day
#    unit_of_measurement: "kWh"
#    device_class: energy
#    state_class: total_increasing
#    accuracy_decimals: 2
#    update_interval: 5s
#    lambda: |-
#      return (id(epv1_day).state + id(epv2_day).state);

#  - platform: modbus_controller
#    modbus_controller_id: inverter_1
#    name: "AC Charge Power"
#    id: prec
#    register_type: read
#    address: 17
#    unit_of_measurement: "W"
#    state_class: measurement
#    value_type: U_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Voltage"
    id: eps_volt
    register_type: read
    address: 20
    unit_of_measurement: "V"
    state_class: measurement
    accuracy_decimals: 1
    value_type: U_WORD
    filters:
       - multiply: 0.1
  
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Frequency"
    id: eps_freq
    register_type: read
    address: 23
    unit_of_measurement: Hz
    state_class: measurement
    accuracy_decimals: 2
    value_type: U_WORD
    filters:
      - multiply: 0.01
  
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "EPS Power"
    id: eps_power
    register_type: read
    address: 24
    unit_of_measurement: W
    state_class: measurement
    device_class: "power"
    value_type: U_WORD

#  - platform: modbus_controller
#    modbus_controller_id: inverter_1_slow
#    name: "Power In Battery (Today)"
#    id: Echg_day
#    register_type: read
#    address: 33
#    unit_of_measurement: "kWh"
#    device_class: energy
#    state_class: total_increasing
#    accuracy_decimals: 2
#    value_type: U_WORD
#    filters: 
#      - multiply: 0.1

#  - platform: modbus_controller
#    modbus_controller_id: inverter_1_slow
#    name: "Power Out Battery (Today)"
#    id: Edischg_day
#    register_type: read
#    address: 34
#    unit_of_measurement: "kWh"
#    device_class: energy
#    state_class: total_increasing
#    accuracy_decimals: 2
#    value_type: U_WORD
#    filters: 
#      - multiply: 0.1

#  - platform: modbus_controller
#    modbus_controller_id: inverter_1_slow
#    name: "Power From Grid (Today)"
#    id: e_grid_today
#    register_type: read
#    address: 37
#    unit_of_measurement: "kWh"
#    device_class: energy
#    state_class: total_increasing
#    accuracy_decimals: 2
#    value_type: U_WORD
#    filters: 
#      - multiply: 0.1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature 1 Inverter"
    id: temp1_inv
    register_type: read
    address: 65
    device_class: temperature
    state_class: measurement
    unit_of_measurement: "°C"
    value_type: S_WORD
  
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature 2 Inverter"
    id: temp2_inv
    register_type: read
    address: 66
    device_class: temperature
    state_class: measurement
    unit_of_measurement: "°C"
    value_type: S_WORD

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Temperature Battery"
    id: temp_battery
    register_type: read
    address: 67
    device_class: temperature
    state_class: measurement
    unit_of_measurement: "°C"
    value_type: S_WORD   

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Max Charge Current BMS"
    id: max_charge_cur
    register_type: read
    address: 81
    unit_of_measurement: "A"
    state_class: measurement
    value_type: U_WORD
    entity_category: diagnostic
    filters: 
      - multiply: 0.01
      - lambda: return x * 10;
          
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Max Discharge Current BMS"
    id: max_discharge_current
    register_type: read
    address: 82
    unit_of_measurement: "A"
    state_class: measurement
    entity_category: diagnostic
    value_type: U_WORD
    filters: 
      - multiply: 0.01
      - lambda: return x * 10;

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Capacity"
    id: bat_cap
    register_type: read
    address: 97
    unit_of_measurement: "Ah"
    state_class: measurement
    value_type: U_WORD
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Battery Current BMS"
    id: bat_cur
    register_type: read
    address: 98
    unit_of_measurement: "A"
    state_class: measurement
    accuracy_decimals: 2
    value_type: S_WORD
    filters: 
      - multiply: 0.01
      - lambda: return x * 10;

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Cell Max Volt"
    id: cell_max_volt
    register_type: read
    address: 101
    device_class: voltage
    unit_of_measurement: "V"
    state_class: measurement
    value_type: U_WORD
    filters: 
      - multiply: 0.001
      - lambda: return x * 100;

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Cell Max Temp"
    id: cell_max_temp
    register_type: read
    address: 103
    device_class: temperature
    unit_of_measurement: "°C"
    state_class: measurement
    value_type: S_WORD
    filters: 
      - multiply: 0.1
    


#  - platform: modbus_controller
#    modbus_controller_id: inverter_1_slow
#    name: "Cell Min Temp"
#    id: cell_min_temp
#    register_type: read
#    address: 104
#    device_class: temperature
#    unit_of_measurement: "°C"
#    state_class: measurement
#    value_type: U_WORD
#    filters: 
#      - multiply: 0.1   


number:  

#  - platform: modbus_controller
#    modbus_controller_id: inverter_1
#    name: "AC Charge Limit"
#    id: ac_charge_limit
#    register_type: holding
#    address: 67
#    value_type: U_WORD
#    unit_of_measurement: "%"
#    min_value: 1
#    max_value: 90
#    step: 1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "On Grid EOD SOC"
    id: on_grid_eod_soc
    register_type: holding
    address: 105
    value_type: U_WORD
    unit_of_measurement: "%"
    min_value: 10
    max_value: 50
    step: 1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Discharge Cut-off SOC"
    id: discharge_cutoff_soc
    register_type: holding
    address: 125
    value_type: U_WORD
    unit_of_measurement: "%"
    min_value: 10
    max_value: 50
    step: 1

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Hysteresis SOC"
    id: hysteresis_soc
    register_type: holding
    address: 253
    value_type: U_WORD
    unit_of_measurement: "%"
    min_value: 5
    max_value: 80
    step: 1


#  - platform: modbus_controller
#    modbus_controller_id: inverter_1
#    name: "Max Charge Current"
#    id: max_charge_cur
#    register_type: holding
#    address: 101
#    value_type: U_WORD
#    unit_of_measurement: "A"
#    min_value: 0
#    max_value: 140
#    step: 1

#  - platform: modbus_controller
#    modbus_controller_id: inverter_1
#    name: "AC Charge Current"
#    id: ac_charge_cur
#    register_type: holding
#    address: 168
#    value_type: U_WORD
#    unit_of_measurement: "A"
#    min_value: 0
#    max_value: 125
#    step: 1

#  - platform: modbus_controller
#    modbus_controller_id: inverter_1
#    name: "AC Charge Start"
#    id: ac_charge_start
#    register_type: holding
#    address: 160
#    value_type: U_WORD
#    unit_of_measurement: "%"
#    min_value: 1
#    max_value: 90
#    step: 1
    

#  - platform: modbus_controller
#    modbus_controller_id: inverter_1
#    name: "AC Charge Stop"
#    id: ac_charge_stop
#    register_type: holding
#    address: 161
#    value_type: U_WORD
#    unit_of_measurement: "%"
#    min_value: 20
#    max_value: 100
#    step: 1


text_sensor:
#Get the Inverter Time - Diagnostics Only - Comment out when not needed
  # - platform: modbus_controller
  #   modbus_controller_id: inverter_1
  #   name: "Inverter Time"
  #   id: inverter_time
  #   register_type: holding
  #   address: 12
  #   register_count: 3
  #   response_size: 6
  #   entity_category: diagnostic
  #   # value_type: U_WORD
  #   raw_encode: HEXBYTES
  #   lambda: |-
  #     // Extract minutes and hours hex strings
  #     std::string hex_month_str = x.substr(0, 2); // First two characters
  #     std::string hex_year_str = x.substr(2, 2);   // Last two characters
  #     std::string hex_hours_str = x.substr(4, 2); // First two characters
  #     std::string hex_day_str = x.substr(6, 2);   // Last two characters
  #     std::string hex_seconds_str = x.substr(8, 2); // First two characters
  #     std::string hex_minutes_str = x.substr(10, -1);   // Last two characters

  #     // Convert hex strings to decimal integers
  #     int year = std::stoi(hex_year_str, nullptr, 16);
  #     int month = std::stoi(hex_month_str, nullptr, 16);
  #     int day = std::stoi(hex_day_str, nullptr, 16);
  #     int hours = std::stoi(hex_hours_str, nullptr, 16);
  #     int minutes = std::stoi(hex_minutes_str, nullptr, 16);
  #     int seconds = std::stoi(hex_seconds_str, nullptr, 16);

  #     // Format the time string as "HH:MM:SS" using snprintf
  #     char buffer[19]; // "MM-DD-YY HH:MM:SS" + null terminator
  #     snprintf(buffer, sizeof(buffer), "%02d-%02d-%02d %02d:%02d:%02d", month, day, year, hours, minutes, seconds);
  #     // Create a std::string from the buffer
  #     std::string time_str(buffer);
  #     // Return the formatted time string
  #     return time_str;


  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Fault Code"
    id: fault
    register_type: read
    address: 60
    register_count: 2
    response_size: 2
    raw_encode: NONE
    entity_category: diagnostic

  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Warning Code"
    id: warning
    register_type: read
    address: 62
    register_count: 2
    response_size: 2
    raw_encode: NONE
    entity_category: diagnostic

# #Testing things and Stuff here  
#   - platform: modbus_controller
#     modbus_controller_id: inverter_1
#     name: "Test_Poke"
#     id: test_number
#     raw_encode: HEXBYTES
#     register_type: holding
#     address: 21
#Serial Number Decoder
  # - platform: modbus_controller
  #   modbus_controller_id: inverter_1
  #   name: "Inverter Serial Number"
  #   id: serial_num
  #   register_type: read
  #   address: 115
  #   register_count: 5
  #   response_size: 9
  #   entity_category: diagnostic
#Working Mode Decoder
  - platform: modbus_controller
    modbus_controller_id: inverter_1
    name: "Working Mode"
    id: state
    register_type: read
    address: 0
    bitmask: 0x1
    raw_encode: HEXBYTES
    lambda: |-
      if(x == "0000"){
          return std::string("Standby");
      }
      if(x == "0001"){
          return std::string("Fault");
      }
      if(x == "0010"){
        return std::string("Grid Mode");
      }
      if(x == "00c0"){
          return std::string("Solar/Battery Mode");
      }
      if(x == "0014"){
          return std::string("Battery/Grid Mode");
      }
      if(x == "0040"){
          return std::string("Battery/Off-Grid Mode");
      }


      return x;


#time:
#  - platform: sntp
#    id: ha_time
#    timezone: America/Denver
#    servers:
#      - 10.6.10.5
#      - 10.6.10.4
#    on_time: 
#      seconds: 0
#      minutes: 0
#      then: 
#        - button.press: sync_time
#
#
#button:
##Push time to the inverter, clock drift do be a thing
#  - platform: template
#    id: sync_time
#    name: "Sync Inverter Time"
#    on_press: 
#      then:
#        - lambda: |-
#            auto time = id(ha_time).now();
#            uint8_t month = time.month;
#            uint16_t year = time.year;
#            uint8_t hour = time.hour;
#            uint8_t day = time.day_of_month;
#            uint8_t second = time.second;
#            uint8_t minute = time.minute;
#
#            // Extract last two digits of the year
#            uint8_t yearLastTwoDigits = year % 100;  // 18
#
#            // Assemble the variables
#            uint16_t monthYear = (month << 8) | yearLastTwoDigits;
#            uint16_t hourDay = (hour << 8) | day;
#            uint16_t secondMinute = (second << 8) | minute;
#            //Assemble Modbus Commands
#            //Month/Year - 12
#            esphome::modbus_controller::ModbusCommandItem write_month_year_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(inverter_1,12,monthYear);
#            inverter_1->queue_command(write_month_year_command);
#            //Day/Hour - 13
#            esphome::modbus_controller::ModbusCommandItem write_hour_day_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(inverter_1,13,hourDay);
#            inverter_1->queue_command(write_hour_day_command);
#            //Minute/Sec - 14
#            esphome::modbus_controller::ModbusCommandItem write_min_sec_command = esphome::modbus_controller::ModbusCommandItem::create_write_single_command(inverter_1,14,secondMinute);
#            inverter_1->queue_command(write_min_sec_command); 